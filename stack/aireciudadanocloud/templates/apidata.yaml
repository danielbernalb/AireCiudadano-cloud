apiVersion: apps/v1
kind: Deployment
metadata:
  name: apidata
spec:
  replicas: 1
  selector:
    matchLabels:
      app: apidata
  template:
    metadata:
      labels:
        app: apidata
    spec:
      containers:
        - name: apidata
          image: python
          command: ["/bin/bash"]
          args: ["-c","/config/run.sh"]
          volumeMounts:
            - name: apidata
              mountPath: /config/
          resources:
            # Ajuste de recursos seg√∫n sea necesario
            requests:
              memory: "500Mi"
              cpu: "300m"
            limits:
              memory: "700Mi"
              cpu: "500m"
      volumes:
        - name: apidata
          configMap:
            name: apidata
            defaultMode: 0777
---
apiVersion: v1
kind: Service
metadata:
  name: apidata-np
spec:
  type: NodePort
  selector:
    app: apidata
  ports:
    - protocol: TCP
      port: 8080
      nodePort: 30003
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: apidata
data:
  run.sh: |
    #!/bin/bash
    pip install paho-mqtt
    pip install requests
    pip install pandas
    pip install numpy
    cd /root/
    while ((1))
    do
      python /config/server.py
      echo "ERROR: Script failed"
    done

  server.py: |
    from http.server import BaseHTTPRequestHandler, HTTPServer
    import urllib.parse
    import json
    import requests
    import pandas as pd
    import datetime
    import numpy as np
    from string import Template

    selected_cols = [
        "PM25", "PM25raw", "PM251", "PM252", "PM1", "CO2", "VOC", "NOx",
        "Humidity", "Temperature", "Noise", "NoisePeak", "RSSI", "Latitude",
        "Longitude", "InOut",
    ]

    def get_data(url, selected_cols):
        try:
            data = requests.get(url).json()['data']['result']
            df = pd.json_normalize(data)

            if 'values' in df.columns:
                df = df.explode('values')
                df['date'] = df['values'].apply(lambda x: datetime.datetime.utcfromtimestamp(x[0]).isoformat())
                df['value'] = df['values'].apply(lambda x: x[1])
                df = df.drop(columns="values")
            elif 'value' in df.columns:
                df['date'] = df['value'].apply(lambda x: datetime.datetime.utcfromtimestamp(x[0]).isoformat())
                df['value'] = df['value'].apply(lambda x: x[1])

            df = df.rename(columns={
                "metric.__name__": "metric_name",
                "metric.exported_job": "station",
            })

            df = df.drop(columns=[col for col in df.columns if "metric." in col]).reset_index(drop=True)
            df = df[df['station'].notnull()]

            df_result = _wide_table(df, selected_cols)

            for col in selected_cols:
                if col in df_result.columns:
                    df_result[col] = df_result[col].astype(float)
            if 'Latitude' in df_result.columns:
                df_result['Latitude'].replace(0, np.nan, inplace=True)
            if 'Longitude' in df_result.columns:
                df_result['Longitude'].replace(0, np.nan, inplace=True)

            return df_result
        except Exception as e:
            print(f'Error in get_data: {str(e)}')
            raise

    def _wide_table(df, selected_cols):
        try:
            df_result = pd.pivot(df, index=['station', 'date'], columns='metric_name', values='value').reset_index()
            all_cols = ['station', 'date'] + selected_cols
            missing_cols = set(all_cols) - set(df_result.columns)
            for col in missing_cols:
                df_result[col] = np.nan
            df_result = df_result[all_cols].reset_index(drop=True)
            df_result.columns.name = ""
            return df_result
        except Exception as e:
            print(f'Pivot Error: {str(e)}')
            raise

    def _get_step(number, choice):
        options = {"minutes": "m", "hours": "h", "days": "d", "weeks": "w", "years": "y"}
        return f"{number}{options[choice]}"

    class RequestHandler(BaseHTTPRequestHandler):
        def _set_headers(self, content_type='text/html'):
            self.send_response(200)
            self.send_header('Content-type', content_type)
            self.end_headers()

        def _serve_html_form(self):
            html_template = Template('''
            <html>
            <body>
            <form action="/dataresult" method="post">
                <label for="variables">Select variables:</label><br>
                <input type="checkbox" id="select_all" onclick="toggle(this);">
                <label for="select_all">Select/Deselect All</label><br>
                $checkboxes
                <br>
                <label for="start_date">Start date/time:</label>
                <input type="date" id="start_date" name="start_date" value="2024-05-09">
                <label for="start_time"> / </label>
                <input type="time" id="start_time" name="start_time" value="08:00"><br><br>
                <label for="end_date">End date/time:</label>
                <input type="date" id="end_date" name="end_date" value="2024-05-09">
                <label for="end_time"> / </label>
                <input type="time" id="end_time" name="end_time" value="10:00"><br><br>
                <label for="aggregation_method">Aggregation method:</label>
                <select id="aggregation_method" name="aggregation_method">
                    <option value="step" selected>Step</option>
                    <option value="average">Average</option>
                </select><br><br>
                <label for="step_number">Step/Average number:</label>
                <input type="number" id="step_number" name="step_number" value="1">
                <label for="step_option">Option:</label>
                <select id="step_option" name="step_option">
                    <option value="minutes">Minutes</option>
                    <option value="hours" selected>Hours</option>
                    <option value="days">Days</option>
                    <option value="weeks">Weeks</option>
                </select><br><br>
                <label for="station_filter">Station Filter:</label>
                <input type="text" id="station_filter" name="station_filter" value=""><br><br>
                <label for="page">Page:</label>
                <input type="number" id="page" name="page" value="1"><br><br>
                <label for="page_size">Page Size:</label>
                <input type="number" id="page_size" name="page_size" value="100"><br><br>
                <input type="submit" value="Submit">
            </form>
            <script>
                function toggle(source) {
                    checkboxes = document.getElementsByName('variables');
                    for (var i = 0; i < checkboxes.length; i++) {
                        checkboxes[i].checked = source.checked;
                    }
                }
            </script>
            </body>
            </html>
            ''')
            checkbox_html = ''.join(
                [f'<input type="checkbox" id="{col}" name="variables" value="{col}" checked>'
                 f'<label for="{col}">{col}</label><br>' for col in selected_cols]
            )
            html_content = html_template.substitute(checkboxes=checkbox_html)
            return html_content

        def do_GET(self):
            print(f"Received GET request for {self.path}")
            if self.path == '/getdata':
                self._set_headers()
                self.wfile.write(self._serve_html_form().encode('utf-8'))
            else:
                self.send_error(404, 'File Not Found: %s' % self.path)

        def do_POST(self):
            print(f"Received POST request for {self.path}")
            if self.path == '/dataresult':
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                params = urllib.parse.parse_qs(post_data.decode('utf-8'))

                # Parse the selected variables from the form data
                variables = params.get('variables', [])
                if not variables:
                    variables = selected_cols

                start_date = params.get('start_date', ['2024-05-09'])[0]
                start_time = params.get('start_time', ['08:00'])[0]
                end_date = params.get('end_date', ['2024-05-09'])[0]
                end_time = params.get('end_time', ['10:00'])[0]
                aggregation_method = params.get('aggregation_method', ['step'])[0]
                step_number = params.get('step_number', ['1'])[0]
                step_option = params.get('step_option', ['hours'])[0]
                station_filter = params.get('station_filter', [''])[0]
                page = int(params.get('page', ['1'])[0])
                page_size = int(params.get('page_size', ['100'])[0])

                start_datetime = f"{start_date}T{start_time}:00Z"
                end_datetime = f"{end_date}T{end_time}:00Z"

                if aggregation_method == 'step':
                    step = _get_step(step_number, step_option)
                elif aggregation_method == 'average':
                    step = f"avg_over_time({step_number}{step_option})"

                base_url = "http://194.242.56.226:30000/api/v1"
                query = '{job%3D"pushgateway"}'
                url = f"{base_url}/query_range?query={query}&start={start_datetime}&end={end_datetime}&step={step}"

                try:
                    df = get_data(url, selected_cols)
                    total_records = df.shape[0]
                    total_pages = int(np.ceil(total_records / page_size))
                    json_data = df.iloc[(page - 1) * page_size: page * page_size].to_dict(orient='records')

                    for record in json_data:
                        for key in record.keys():
                            if pd.isna(record[key]):
                                record[key] = None

                    grouped_data = {}
                    for record in json_data:
                        station = record.pop('station')
                        if station not in grouped_data:
                            grouped_data[station] = []
                        grouped_data[station].append(record)

                    response = {
                        'total_records': total_records,
                        'total_pages': total_pages,
                        'page': page,
                        'page_size': page_size,
                        'data': grouped_data,
                    }

                    self._set_headers(content_type='application/json')
                    self.wfile.write(json.dumps(response).encode('utf-8'))

                except Exception as e:
                    print(f"Error processing data: {str(e)}")
                    self.send_error(500, 'Internal Server Error')
            else:
                self.send_error(404, 'File Not Found: %s' % self.path)

    def run(server_class=HTTPServer, handler_class=RequestHandler, port=8080):
        server_address = ('', port)
        httpd = server_class(server_address, handler_class)
        print(f'Starting httpd server on port {port}')
        httpd.serve_forever()

    if __name__ == '__main__':
        from sys import argv
        if len(argv) == 2:
            run(port=int(argv[1]))
        else:
            run()
