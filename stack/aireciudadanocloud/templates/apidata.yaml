apiVersion: apps/v1
kind: Deployment
metadata:
  name: apidata
spec:
  replicas: 1
  selector:
    matchLabels:
      app: apidata
  template:
    metadata:
      labels:
        app: apidata
    spec:
      containers:
        - name: apidata
          image: python
          command: ["/bin/bash", "-c", "/config/run.sh"]
          volumeMounts:
            - name: apidata-python
              mountPath: /config/
            - name: apidata-template
              mountPath: /config/templates/
          resources:
            # Ajuste de recursos seg√∫n sea necesario
            requests:
              memory: "400Mi"
              cpu: "200m"
            limits:
              memory: "600Mi"
              cpu: "400m"
      volumes:
        - name: apidata-python
          configMap:
            name: apidata-python
            defaultMode: 0777
        - name: apidata-template
          configMap:
            name: apidata-template
            defaultMode: 0777
---
apiVersion: v1
kind: Service
metadata:
  name: apidata-np
spec:
  type: NodePort
  selector:
    app: apidata
  ports:
    - protocol: TCP
      port: 8081
      nodePort: 30003
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: apidata-template
data:
  form.html: |
    <form action="/dataresult" method="post">
        <h2>API AIRECIUDADANO v1.0</h2><br>
        <h3>Instrucciones en aireciudadano.com/api</h3><br>
        <label for="variables">Select variables:</label><br>
        <input type="checkbox" id="select_all" onclick="toggle(this);">
        <label for="select_all">Select/Deselect All</label><br>

        <input type="checkbox" id="PM25" name="variables" value="PM25">
        <label for="PM25">PM25</label><br>

        <input type="checkbox" id="PM25raw" name="variables" value="PM25raw">
        <label for="PM25raw">PM25raw</label><br>

        <input type="checkbox" id="PM251" name="variables" value="PM251">
        <label for="PM251">PM251</label><br>

        <input type="checkbox" id="PM252" name="variables" value="PM252">
        <label for="PM252">PM252</label><br>

        <input type="checkbox" id="PM1" name="variables" value="PM1">
        <label for="PM1">PM1</label><br>

        <input type="checkbox" id="CO2" name="variables" value="CO2">
        <label for="CO2">CO2</label><br>

        <input type="checkbox" id="VOC" name="variables" value="VOC">
        <label for="VOC">VOC</label><br>

        <input type="checkbox" id="NOx" name="variables" value="NOx">
        <label for="NOx">NOx</label><br>

        <input type="checkbox" id="Humidity" name="variables" value="Humidity">
        <label for="Humidity">Humidity</label><br>

        <input type="checkbox" id="Temperature" name="variables" value="Temperature">
        <label for="Temperature">Temperature</label><br>

        <input type="checkbox" id="Noise" name="variables" value="Noise">
        <label for="Noise">Noise</label><br>

        <input type="checkbox" id="NoisePeak" name="variables" value="NoisePeak">
        <label for="NoisePeak">NoisePeak</label><br>

        <input type="checkbox" id="RSSI" name="variables" value="RSSI">
        <label for="RSSI">RSSI</label><br>

        <input type="checkbox" id="Latitude" name="variables" value="Latitude">
        <label for="Latitude">Latitude</label><br>

        <input type="checkbox" id="Longitude" name="variables" value="Longitude">
        <label for="Longitude">Longitude</label><br>

        <input type="checkbox" id="InOut" name="variables" value="InOut">
        <label for="InOut">InOut</label><br>

        <br>
        <label for="start_date">Start date/time:</label>
        <input type="date" id="start_date" name="start_date" value="{{"{{ start_date }}"}}">
        <label for="start_time"> / </label>
        <input type="time" id="start_time" name="start_time" value="{{"{{ start_time }}"}}" step="3600" list="hour-markers"><br><br>
        <label for="end_date">End date/time:</label>
        <input type="date" id="end_date" name="end_date" value="{{"{{ end_date }}"}}">
        <label for="end_time"> / </label>
        <input type="time" id="end_time" name="end_time" value="{{"{{ end_time }}"}}" step="3600" list="hour-markers"><br><br>
        <datalist id="hour-markers">
            {%"{% for hour in range(24) %}"%}
                <option value="{{"{{ '%02d:00'|format(hour) }}"}}"></option>
            {%"{% endfor %}"%}
        </datalist>
        <label for="aggregation_method">Aggregation method:</label>
        <select id="aggregation_method" name="aggregation_method">
            <option value="step" {%"{% if aggregation_method == 'step' %}"%}selected{%"{% endif %}"%}>Step</option>
            <option value="average" {%"{% if aggregation_method == 'average' %}"%}selected{%"{% endif %}"%}>Average</option>
        </select><br><br>
        <label for="step_number">Step/Average number:</label>
        <input type="number" id="step_number" name="step_number" value="{{"{{ step_number }}"}}">
        <label for="step_option">Option:</label>
        <select id="step_option" name="step_option">
            <option value="minutes" {%"{% if step_option == 'minutes' %}"%}selected{%"{% endif %}"%}>Minutes</option>
            <option value="hours" {%"{% if step_option == 'hours' %}"%}selected{%"{% endif %}"%}>Hours</option>
            <option value="days" {%"{% if step_option == 'days' %}"%}selected{%"{% endif %}"%}>Days</option>
            <option value="weeks" {%"{% if step_option == 'weeks' %}"%}selected{%"{% endif %}"%}>Weeks</option>
        </select><br><br>
        <label for="station_filter">Station Filter:</label>
        <input type="text" id="station_filter" name="station_filter" value=""><br><br>
        <input type="submit" value="Submit">
    </form>
    <script>
        function toggle(source) {
            checkboxes = document.getElementsByName('variables');
            for (var i = 0; i < checkboxes.length; i++) {
                checkboxes[i].checked = source.checked;
            }
        }
    </script>
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: apidata-python
data:
  run.sh: |
    #!/bin/bash
    pip install flask
    pip install paho-mqtt
    pip install requests
    pip install pandas
    pip install numpy
    cd /root/
    while ((1))
    do
      python /config/server.py
      echo "ERROR: Script failed"
    done

  server.py: |
    from flask import Flask, request, jsonify, render_template
    import requests
    import pandas as pd
    import datetime
    import numpy as np
    import json

    # Constants
    selected_cols = [
        "PM25", "PM25raw", "PM251", "PM252", "PM1", "CO2", "VOC", "NOx",
        "Humidity", "Temperature", "Noise", "NoisePeak", "RSSI", "Latitude",
        "Longitude", "InOut",
    ]

    # Flask application
    app = Flask(__name__)

    # Get data from API
    def get_data(url, selected_cols):
        try:
            data = requests.get(url).json()['data']['result']
            df = pd.json_normalize(data)

            if 'values' in df.columns:
                df = df.explode('values')
                df['date'] = df['values'].apply(lambda x: datetime.datetime.utcfromtimestamp(x[0]).isoformat())
                df['value'] = df['values'].apply(lambda x: x[1])
                df = df.drop(columns="values")
            elif 'value' in df.columns:
                df['date'] = df['value'].apply(lambda x: datetime.datetime.utcfromtimestamp(x[0]).isoformat())
                df['value'] = df['value'].apply(lambda x: x[1])

            df = df.rename(columns={
                "metric.__name__": "metric_name",
                "metric.exported_job": "station",
            })

            df = df.drop(columns=[col for col in df.columns if "metric." in col]).reset_index(drop=True)
            df = df[df['station'].notnull()]

            df_result = _wide_table(df, selected_cols)

            for col in selected_cols:
                if col in df_result.columns:
                    df_result[col] = df_result[col].astype(float)
            if 'Latitude' in df_result.columns:
                df_result['Latitude'].replace(0, np.nan, inplace=True)
            if 'Longitude' in df_result.columns:
                df_result['Longitude'].replace(0, np.nan, inplace=True)

            return df_result
        except Exception as e:
            app.logger.error(f'Error in get_data: {str(e)}')
            raise

    # Function to get wide table
    def _wide_table(df, selected_cols):
        try:
            df_result = pd.pivot(df, index=['station', 'date'], columns='metric_name', values='value').reset_index()
            all_cols = ['station', 'date'] + selected_cols
            missing_cols = set(all_cols) - set(df_result.columns)
            for col in missing_cols:
                df_result[col] = np.nan
            df_result = df_result[all_cols].reset_index(drop=True)
            df_result.columns.name = ""
            return df_result
        except Exception as e:
            app.logger.error(f'Pivot Error: {str(e)}')
            raise

    # Constructor of the step value for time range queries
    def _get_step(number, choice):
        options = {"minutes": "m", "hours": "h", "days": "d", "weeks": "w", "years": "y"}
        return f"{number}{options[choice]}"

    @app.route('/getdata')
    def index():
        return render_template('form.html',
                            start_date=request.args.get('start_date', '2024-05-09'),
                            start_time=request.args.get('start_time', '08:00'),
                            end_date=request.args.get('end_date', '2024-05-09'),
                            end_time=request.args.get('end_time', '10:00'),
                            step_number=request.args.get('step_number', '1'),
                            step_option=request.args.get('step_option', 'hours'),
                            aggregation_method=request.args.get('aggregation_method', 'step'))

    @app.route('/dataresult', methods=['POST'])
    def data():
        variables = request.form.getlist('variables')
        base_url = "http://88.99.187.134:30000/api/v1"
        query = '{job%3D"pushgateway"}'

        start_date = request.form['start_date']
        start_time = request.form['start_time']
        end_date = request.form['end_date']
        end_time = request.form['end_time']
        step_number = request.form['step_number']
        step_option = request.form['step_option']
        aggregation_method = request.form['aggregation_method']
        station_filter = request.form.get('station_filter', '')

        # Adjust start_datetime to be one hour earlier
        start_datetime = f"{start_date}T{start_time}:00Z"
        start_datetime_adjusted = (datetime.datetime.fromisoformat(start_datetime[:-1]) - datetime.timedelta(hours=1)).isoformat() + 'Z'
        end_datetime = f"{end_date}T{end_time}:00Z"

        if aggregation_method == 'average':
            step = '1m'
        else:
            step = _get_step(step_number, step_option)

        url = f"{base_url}/query_range?query={query}&start={start_datetime_adjusted}&end={end_datetime}&step={step}"

        try:
            obs = get_data(url, variables)
            if station_filter:
                filters = station_filter.split(',')
                obs = obs[obs['station'].str.contains('|'.join(filters), case=False)]

            if aggregation_method == 'average':
                obs['date'] = pd.to_datetime(obs['date'], utc=True)
                obs.set_index(['station', 'date'], inplace=True)

                obs = obs.apply(pd.to_numeric, errors='coerce')
                hourly_obs = []

                start_time_dt = pd.to_datetime(start_datetime, utc=True)
                end_time_dt = pd.to_datetime(end_datetime, utc=True)

                for station, group in obs.groupby('station'):
                    current_time = start_time_dt
                    while current_time <= end_time_dt:
                        mask = (group.index.get_level_values('date') > current_time - pd.Timedelta(hours=1)) & (group.index.get_level_values('date') <= current_time)
                        hourly_avg = group.loc[mask].mean()
                        hourly_avg['station'] = station
                        hourly_avg['date'] = current_time.strftime('%Y-%m-%dT%H:%M:%SZ')
                        hourly_obs.append(hourly_avg)
                        current_time += pd.Timedelta(hours=1)

                obs = pd.DataFrame(hourly_obs).reset_index(drop=True)

            # Filter the results to ensure dates are within the original specified range
            obs = obs[(obs['date'] >= start_datetime) & (obs['date'] <= end_datetime)]

            total_records = obs.shape[0]

            # Convert DataFrame to dictionary and replace NaN with None explicitly
            json_data = obs.to_dict(orient='records')
            for record in json_data:
                for key, value in record.items():
                    if pd.isna(value):
                        record[key] = None

            grouped_data = {}
            for record in json_data:
                station = record.pop('station')
                if station not in grouped_data:
                    grouped_data[station] = []
                grouped_data[station].append(record)

            return jsonify({
                'total_records': total_records,
                'data': grouped_data
            })
        except Exception as e:
            app.logger.error(f'Error in data endpoint: {str(e)}')
            return jsonify({'error': str(e)})

    def run(server_class=HTTPServer, handler_class=RequestHandler, port=8081):
        server_address = ('', port)
        httpd = server_class(server_address, handler_class)
        logging.info(f'Starting httpd server on port {port}')
        httpd.serve_forever()

    if __name__ == '__main__':
        from sys import argv
        if len(argv) == 2:
            run(port=int(argv[1]))
        else:
            run()
