apiVersion: apps/v1
kind: Deployment
metadata:
  name: apidata
spec:
  replicas: 1
  selector:
    matchLabels:
      app: apidata
  template:
    metadata:
      labels:
        app: apidata
    spec:
      containers:
        - name: apidata
          image: python
          command: ["/bin/bash", "-c", "/config/run.sh"]
          volumeMounts:
            - name: apidata
              mountPath: /config/
          resources:
            # Ajuste de recursos seg√∫n sea necesario
            requests:
              memory: "500Mi"
              cpu: "300m"
            limits:
              memory: "700Mi"
              cpu: "500m"
      volumes:
        - name: apidata
          configMap:
            name: apidata
            defaultMode: 0777
---
apiVersion: v1
kind: Service
metadata:
  name: apidata-np
spec:
  type: NodePort
  selector:
    app: apidata
  ports:
    - protocol: TCP
      port: 8080
      nodePort: 30003
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: apidata
data:
  run.sh: |
    #!/bin/bash
    pip install paho-mqtt
    pip install requests
    pip install pandas
    pip install numpy
    cd /root/
    while ((1))
    do
      python /config/server.py
      echo "ERROR: Script failed"
    done

  server.py: |
    import pandas as pd
    import datetime
    import numpy as np
    import logging
    import urllib.parse
    import requests
    import json
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from string import Template

    logging.basicConfig(level=logging.DEBUG)

    selected_cols = [
        "PM25", "PM25raw", "PM251", "PM252", "PM1", "CO2", "VOC", "NOx",
        "Humidity", "Temperature", "Noise", "NoisePeak", "RSSI", "Latitude",
        "Longitude", "InOut",
    ]

    def get_data(url, variables):
        try:
            logging.debug(f"Requesting data from URL: {url}")
            response = requests.get(url)
            logging.debug(f"Response status code: {response.status_code}")
            response.raise_for_status()
            data = response.json()
            logging.debug(f"Data received: {str(data)[:100]}...")  # Log first 100 characters

            if 'data' not in data or 'result' not in data['data']:
                raise ValueError(f"Unexpected data structure: {data}")
            
            result = data['data']['result']
            
            if not result:
                return pd.DataFrame()  # Return an empty DataFrame if no results

            if isinstance(result, list):
                df = pd.json_normalize(result)
                if 'values' in df.columns:
                    df = df.explode('values')
                    df['date'] = df['values'].apply(lambda x: datetime.datetime.utcfromtimestamp(x[0]).isoformat())
                    df['value'] = df['values'].apply(lambda x: x[1])
                    df = df.drop(columns="values")
                elif 'value' in df.columns:
                    df['date'] = df['value'].apply(lambda x: datetime.datetime.utcfromtimestamp(x[0]).isoformat())
                    df['value'] = df['value'].apply(lambda x: x[1])
            elif isinstance(result, dict):
                df = pd.DataFrame([result])
                df['date'] = datetime.datetime.utcfromtimestamp(result['value'][0]).isoformat()
                df['value'] = result['value'][1]
            else:
                raise ValueError(f"Unexpected result structure: {result}")

            df = df.rename(columns={
                "metric.__name__": "metric_name",
                "metric.exported_job": "station",
            })

            df = df.drop(columns=[col for col in df.columns if "metric." in col]).reset_index(drop=True)
            df = df[df['station'].notnull()]

            df_result = _wide_table(df, variables)

            for col in variables:
                if col in df_result.columns:
                    df_result[col] = df_result[col].astype(float)
            if 'Latitude' in df_result.columns:
                df_result['Latitude'].replace(0, np.nan, inplace=True)
            if 'Longitude' in df_result.columns:
                df_result['Longitude'].replace(0, np.nan, inplace=True)

            return df_result
        except requests.RequestException as e:
            logging.error(f"Request failed: {e}", exc_info=True)
            raise
        except ValueError as e:
            logging.error(f"Data processing error: {e}", exc_info=True)
            raise
        except Exception as e:
            logging.error(f"Unexpected error: {e}", exc_info=True)
            raise

    def _wide_table(df, variables):
        try:
            df_result = pd.pivot(df, index=['station', 'date'], columns='metric_name', values='value').reset_index()
            all_cols = ['station', 'date'] + variables
            missing_cols = set(all_cols) - set(df_result.columns)
            for col in missing_cols:
                df_result[col] = np.nan
            df_result = df_result[all_cols].reset_index(drop=True)
            df_result.columns.name = ""
            return df_result
        except Exception as e:
            logging.error(f'Pivot Error: {str(e)}', exc_info=True)
            raise

    def _get_step(number, choice):
        options = {"minutes": "m", "hours": "h", "days": "d", "weeks": "w", "years": "y"}
        return f"{number}{options[choice]}"

    def _resample_and_average(df, step, step_unit):
        try:
            df['date'] = pd.to_datetime(df['date'])
            df.set_index('date', inplace=True)
            df = df.resample(f'{step}{step_unit[0].upper()}').mean()
            df.reset_index(inplace=True)
            return df
        except Exception as e:
            logging.error(f'Resample and average error: {str(e)}', exc_info=True)
            raise

    class RequestHandler(BaseHTTPRequestHandler):
        def _set_headers(self, content_type='text/html'):
            self.send_response(200)
            self.send_header('Content-type', content_type)
            self.end_headers()

        def _serve_html_form(self):
            html_template = Template('''
            <html>
            <body>
            <form action="/dataresult" method="post">
                <label for="variables">Select variables:</label><br>
                <input type="checkbox" id="select_all" onclick="toggle(this);">
                <label for="select_all">Select/Deselect All</label><br>
                $checkboxes
                <br>
                <label for="start_date">Start date/time:</label>
                <input type="date" id="start_date" name="start_date" value="2024-05-09">
                <label for="start_time"> / </label>
                <input type="time" id="start_time" name="start_time" value="08:00"><br><br>
                <label for="end_date">End date/time:</label>
                <input type="date" id="end_date" name="end_date" value="2024-05-09">
                <label for="end_time"> / </label>
                <input type="time" id="end_time" name="end_time" value="10:00"><br><br>
                <label for="aggregation_method">Aggregation method:</label>
                <select id="aggregation_method" name="aggregation_method">
                    <option value="step" selected>Step</option>
                    <option value="average">Average</option>
                </select><br><br>
                <label for="step_number">Step/Average number:</label>
                <input type="number" id="step_number" name="step_number" value="1">
                <label for="step_option">Option:</label>
                <select id="step_option" name="step_option">
                    <option value="minutes">Minutes</option>
                    <option value="hours" selected>Hours</option>
                    <option value="days">Days</option>
                    <option value="weeks">Weeks</option>
                </select><br><br>
                <label for="station_filter">Station Filter:</label>
                <input type="text" id="station_filter" name="station_filter" value=""><br><br>
                <label for="page">Page:</label>
                <input type="number" id="page" name="page" value="1"><br><br>
                <label for="page_size">Page Size:</label>
                <input type="number" id="page_size" name="page_size" value="100"><br><br>
                <input type="submit" value="Submit">
            </form>
            <script>
                function toggle(source) {
                    checkboxes = document.getElementsByName('variables');
                    for (var i = 0; i < checkboxes.length; i++) {
                        checkboxes[i].checked = source.checked;
                    }
                }
            </script>
            </body>
            </html>
            ''')
            checkbox_html = ''.join(
                [f'<input type="checkbox" id="{col}" name="variables" value="{col}" checked>'
                 f'<label for="{col}">{col}</label><br>' for col in selected_cols]
            )
            html_content = html_template.substitute(checkboxes=checkbox_html)
            return html_content

        def do_GET(self):
            logging.info(f"Received GET request for {self.path}")
            if self.path == '/getdata':
                self._set_headers()
                self.wfile.write(self._serve_html_form().encode('utf-8'))
            else:
                self.send_error(404, 'File Not Found: %s' % self.path)

        def do_POST(self):
            logging.info(f"Received POST request for {self.path}")
            if self.path == '/dataresult':
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                params = urllib.parse.parse_qs(post_data.decode('utf-8'))

                variables = params.get('variables', [])
                if not variables:
                    variables = selected_cols

                start_date = params.get('start_date', ['2024-05-09'])[0]
                start_time = params.get('start_time', ['08:00'])[0]
                end_date = params.get('end_date', ['2024-05-09'])[0]
                end_time = params.get('end_time', ['10:00'])[0]
                aggregation_method = params.get('aggregation_method', ['step'])[0]
                step_number = params.get('step_number', ['1'])[0]
                step_option = params.get('step_option', ['hours'])[0]
                station_filter = params.get('station_filter', [''])[0].strip()

                # Split the filter into individual words
                filter_words = [word.strip().lower() for word in station_filter.split() if word.strip()]

                page = int(params.get('page', ['1'])[0])
                page_size = int(params.get('page_size', ['100'])[0])

                start_datetime = f"{start_date}T{start_time}:00Z"
                end_datetime = f"{end_date}T{end_time}:00Z"

                base_url = "http://194.242.56.226:30000/api/v1"
                query = '{job="pushgateway"}'

                if aggregation_method == 'step':
                    step = _get_step(step_number, step_option)
                    url = f"{base_url}/query_range?query={query}&start={start_datetime}&end={end_datetime}&step={step}"
                elif aggregation_method == 'average':
                    range = "1m"  # Fixed 1 minute range for average
                    query_avg = f"avg_over_time({query}[{range}])"
                    step = _get_step(step_number, step_option)
                    url = f"{base_url}/query_range?query={urllib.parse.quote(query_avg)}&start={start_datetime}&end={end_datetime}&step=1m"

                logging.debug(f"Constructed URL: {url}")

                try:
                    df = get_data(url, variables)

                    if df.empty:
                        response = {
                            'total_records': 0,
                            'total_pages': 0,
                            'page': page,
                            'page_size': page_size,
                            'data': {},
                        }
                    else:
                        # Apply the station filter if provided
                        if filter_words:
                            df['station_lower'] = df['station'].str.lower()
                            mask = df['station_lower'].apply(lambda x: all(word in x for word in filter_words))
                            df = df[mask]
                            df = df.drop('station_lower', axis=1)

                        total_records = df.shape[0]
                        total_pages = int(np.ceil(total_records / page_size))
                        json_data = df.iloc[(page - 1) * page_size: page * page_size].to_dict(orient='records')

                        for record in json_data:
                            for key in record.keys():
                                if pd.isna(record[key]):
                                    record[key] = None

                        grouped_data = {}
                        for record in json_data:
                            station = record.pop('station')
                            if station not in grouped_data:
                                grouped_data[station] = []
                            grouped_data[station].append(record)

                        response = {
                            'total_records': total_records,
                            'total_pages': total_pages,
                            'page': page,
                            'page_size': page_size,
                            'data': grouped_data,
                        }

                    self._set_headers(content_type='application/json')
                    self.wfile.write(json.dumps(response).encode('utf-8'))

                except Exception as e:
                    logging.error(f"Error processing data: {str(e)}", exc_info=True)
                    self.send_error(500, f'Internal Server Error: {str(e)}')
            else:
                self.send_error(404, 'File Not Found: %s' % self.path)

    def run(server_class=HTTPServer, handler_class=RequestHandler, port=8080):
        server_address = ('', port)
        httpd = server_class(server_address, handler_class)
        logging.info(f'Starting httpd server on port {port}')
        httpd.serve_forever()

    if __name__ == '__main__':
        from sys import argv
        if len(argv) == 2:
            run(port=int(argv[1]))
        else:
            run()
